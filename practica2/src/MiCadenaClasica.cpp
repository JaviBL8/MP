#include "../include/MiCadenaClasica.h"#include <iostream>using namespace std;int longitud_cadena(char *cadena){	char *p;	int longitud=1;	p=cadena;	while(*p!='\0'){		p++;		longitud++;	}	return longitud;}	bool palindromo(char *cadena){	char *p;	char *q;	p=cadena;	q=cadena;	bool aux=true;	while(*p!='\0')p++;	//p se queda apuntando a '\0'; para solucionarlo...	p=p-1;		while(*q!='\0'){				if (*q!=*p){			aux=false;			}		p--;		q++;	}	return aux;}//El ejercicio estÃ¡ mal planteado pero considero que esto es lo que pideint comparar_cadenas(char *primera, char *segunda){	if (longitud_cadena(primera)>=longitud_cadena(segunda))	{		while(*primera!='\0')primera++;		int a;		a=*(primera-1);		return a;	}	else{		while(*segunda!='\0')segunda++;		int b;		b=*(segunda-1);		return b;	}}char * copiar_cadena(char *copia,char *original){	copia=original;	return copia;}char * encadenar_cadena(char *compuesta,char *cadena){	char *p,*q;	int i=0;	p=compuesta;	q=cadena;	while(*p!='\0'){		p++;		i++;	}	while(*q){		*(compuesta+i)=*q++;		i++;	}	*(compuesta+i)='\0';	return compuesta;}char * obtener_subcadena(char *cadena, int p, int l){	if ((l-p)>longitud_cadena(cadena)){		return cadena;	}	else{		char *sub;		int i=0;		for (p; p <= l; p++){			*(sub+i)=*(cadena+p);			i++;		}		*(sub+i)='\0';		return sub;	}}char * invertir_cadena(char *cadena){	char *p,*aux;	int i=0;	const int TOPE=100;	char cadena1[TOPE];	p=cadena;	aux=cadena1;	while(*p!='\0')p++;	while(*(cadena+i)!='\0'){		*(aux+i)=*(p-i-1);		i++;	}	*(aux+i)='\0';	cadena=aux;	return cadena;}